# -*- coding: utf-8 -*-
"""AtividadeSort.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vXcVlZpz3DLsduVCKz1x_gc0lNYRtpi7

Aluno:Luiz José Mendonça Duarte
"""

pip install numpy matplotlib

"""Insertion Sort:"""

import random
import time

def insertionSort(lista1):              ##Todas essas funções insertionSort tem o mesmo objetivo de ordenar do metódo insertion sort
    for i in range(1, len(lista1)):     ##Inclusive eu fiz o código olhando pelo slide e trocando pra python e vendo se funcionava
        aux = lista1[i]
        j = i - 1
        while j >= 0 and aux < lista1[j]:
            lista1[j + 1] = lista1[j]
            j -= 1
        lista1[j + 1] = aux

def insertionSort2(lista2):
    for i in range(1, len(lista2)):
        aux = lista2[i]
        j = i - 1
        while j >= 0 and aux < lista2[j]:
            lista2[j + 1] = lista2[j]
            j -= 1
        lista2[j + 1] = aux

def insertionSort3(lista3):
    for i in range(1, len(lista3)):
        aux = lista3[i]
        j = i - 1
        while j >= 0 and aux < lista3[j]:
            lista3[j + 1] = lista3[j]
            j -= 1
        lista3[j + 1] = aux

def ordenar_lista():                                                  #O objetivo da funçao ordenar lista , é justamente ordenar as listas e calcular o tempo de execução de
    cem = 100                                                         #Cada uma
    lista1 = []
    mil = 1000                                                        #Para criar os números aleatórios eu usei a função random.randint e o valor colocado dentro foi um valor
    lista2 = []                                                       #Que eu estipulei para acorrer
    dezm = 10000
    lista3 = []
    for _ in range(cem):
        lista1.append(random.randint(-99999, 99999))

    print("Insertion Sort 1 com cem elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista1)

    start_time = time.time()                                         #Essa parte de calcular o tempo de execução eu nn consegui fazer e procurei uma pronta , essa funcionou

    insertionSort(lista1)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista1)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(mil):
        lista2.append(random.randint(-99999, 99999))

    print("\n\nInsertion Sort 1 com mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista2)

    start_time = time.time()

    insertionSort2(lista2)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista2)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(dezm):
        lista3.append(random.randint(-999999, 999999))

    print("\n\nInsertion Sort 1 com dez mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista3)

    start_time = time.time()

    insertionSort2(lista3)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista3)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))


ordenar_lista()

import random
import time
import matplotlib.pyplot as plt

def insertionSort(lista):
    for i in range(1, len(lista)):
        aux = lista[i]
        j = i - 1
        while j >= 0 and aux < lista[j]:
            lista[j + 1] = lista[j]
            j -= 1
        lista[j + 1] = aux

def ordenar_e_medir_tempo(tamanho):
    lista = [random.randint(-99999, 99999) for _ in range(tamanho)]

    start_time = time.time()
    insertionSort(lista)
    end_time = time.time()

    execution_time = end_time - start_time

    print(f"Insertion Sort com {tamanho} elementos no vetor:")
    print("Tempo de execução: {:.6f} segundos".format(execution_time))

    return execution_time

tamanhos = [100, 1000, 10000]
tempos = []

for tamanho in tamanhos:
    tempo_execucao = ordenar_e_medir_tempo(tamanho)
    tempos.append(tempo_execucao)

# Calcular os tempos de execução usando o gráfico
plt.figure(figsize=(8, 6))
plt.plot(tamanhos, tempos, marker='o')
plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo de Execução (s)')
plt.title('Tempo de Execução do Insertion Sort')
plt.grid(True)
plt.show()

"""Bubble sort"""

import random
import time

def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

def ordenar_lista():
    cem = 100
    lista1 = []
    mil = 1000
    lista2 = []
    dezm = 10000
    lista3 = []

    for _ in range(cem):
        lista1.append(random.randint(-99999, 99999))

    print("Bubble Sort com cem elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista1)

    start_time = time.time()

    bubble_sort(lista1)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista1)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(mil):
        lista2.append(random.randint(-99999, 99999))

    print("\n\nBubble Sort com mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista2)

    start_time = time.time()

    bubble_sort(lista2)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista2)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(dezm):
        lista3.append(random.randint(-999999, 999999))

    print("\n\nBubble Sort com dez mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista3)

    start_time = time.time()

    bubble_sort(lista3)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista3)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

ordenar_lista()

import random
import time
import matplotlib.pyplot as plt

def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

def ordenar_e_medir_tempo(tamanho):
    lista = [random.randint(-99999, 99999) for _ in range(tamanho)]

    start_time = time.time()
    bubble_sort(lista)
    end_time = time.time()

    execution_time = end_time - start_time

    print(f"Bubble Sort com {tamanho} elementos no vetor:")
    print("Tempo de execução: {:.6f} segundos".format(execution_time))

    return execution_time

tamanhos = [100, 1000, 10000]
tempos = []

for tamanho in tamanhos:
    tempo_execucao = ordenar_e_medir_tempo(tamanho)
    tempos.append(tempo_execucao)

# Calcular os tempos de execução usando o gráfico
plt.figure(figsize=(8, 6))
plt.plot(tamanhos, tempos, marker='o')
plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo de Execução (s)')
plt.title('Tempo de Execução do Bubble Sort')
plt.grid(True)
plt.show()

"""Selection sort:"""

import random
import time

def selection_sort(arr):
    n = len(arr)

    for i in range(n):
        # Encontra o índice do menor elemento não ordenado restante
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j

        # Troca o menor elemento encontrado com o primeiro elemento não ordenado
        arr[i], arr[min_index] = arr[min_index], arr[i]

def ordenar_lista():
    cem = 100
    lista1 = []
    mil = 1000
    lista2 = []
    dezm = 10000
    lista3 = []

    for _ in range(cem):
        lista1.append(random.randint(-99999, 99999))

    print("Selection Sort com cem elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista1)

    start_time = time.time()

    selection_sort(lista1)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista1)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(mil):
        lista2.append(random.randint(-99999, 99999))

    print("\n\nSelection Sort com mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista2)

    start_time = time.time()

    selection_sort(lista2)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista2)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(dezm):
        lista3.append(random.randint(-999999, 999999))

    print("\n\nSelection Sort com dez mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista3)

    start_time = time.time()

    selection_sort(lista3)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista3)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

ordenar_lista()

import random
import time
import matplotlib.pyplot as plt

def selection_sort(arr):
    n = len(arr)

    for i in range(n):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j

        arr[i], arr[min_index] = arr[min_index], arr[i]

def ordenar_e_medir_tempo(tamanho):
    lista = [random.randint(-99999, 99999) for _ in range(tamanho)]

    start_time = time.time()
    selection_sort(lista)
    end_time = time.time()

    execution_time = end_time - start_time

    print(f"Selection Sort com {tamanho} elementos no vetor:")
    print("Tempo de execução: {:.6f} segundos".format(execution_time))

    return execution_time

tamanhos = [100, 1000, 10000]
tempos = []

for tamanho in tamanhos:
    tempo_execucao = ordenar_e_medir_tempo(tamanho)
    tempos.append(tempo_execucao)

plt.figure(figsize=(8, 6))
plt.plot(tamanhos, tempos, marker='o')
plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo de Execução (s)')
plt.title('Tempo de Execução do Selection Sort')
plt.grid(True)
plt.show()