# -*- coding: utf-8 -*-
"""AtividadeSort2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lWaEVhBKsSpqnSZsO5OQkSsXPNkzyxZC

Aluno:Luiz José Mendonça Duarte
"""

pip install numpy matplotlib

"""Insertion Sort:"""

import random
import time

def insertionSort(lista1):              ##Todas essas funções insertionSort tem o mesmo objetivo de ordenar do metódo insertion sort
    for i in range(1, len(lista1)):     ##Inclusive eu fiz o código olhando pelo slide e trocando pra python e vendo se funcionava
        aux = lista1[i]
        j = i - 1
        while j >= 0 and aux < lista1[j]:
            lista1[j + 1] = lista1[j]
            j -= 1
        lista1[j + 1] = aux

def insertionSort2(lista2):
    for i in range(1, len(lista2)):
        aux = lista2[i]
        j = i - 1
        while j >= 0 and aux < lista2[j]:
            lista2[j + 1] = lista2[j]
            j -= 1
        lista2[j + 1] = aux

def insertionSort3(lista3):
    for i in range(1, len(lista3)):
        aux = lista3[i]
        j = i - 1
        while j >= 0 and aux < lista3[j]:
            lista3[j + 1] = lista3[j]
            j -= 1
        lista3[j + 1] = aux

def ordenar_lista():                                                  #O objetivo da funçao ordenar lista , é justamente ordenar as listas e calcular o tempo de execução de
    cem = 100                                                         #Cada uma
    lista1 = []
    mil = 1000                                                        #Para criar os números aleatórios eu usei a função random.randint e o valor colocado dentro foi um valor
    lista2 = []                                                       #Que eu estipulei para acorrer
    dezm = 10000
    lista3 = []
    for _ in range(cem):
        lista1.append(random.randint(-99999, 99999))

    print("Insertion Sort 1 com cem elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista1)

    start_time = time.time()                                         #Essa parte de calcular o tempo de execução eu nn consegui fazer e procurei uma pronta , essa funcionou

    insertionSort(lista1)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista1)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(mil):
        lista2.append(random.randint(-99999, 99999))

    print("\n\nInsertion Sort 1 com mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista2)

    start_time = time.time()

    insertionSort2(lista2)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista2)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(dezm):
        lista3.append(random.randint(-999999, 999999))

    print("\n\nInsertion Sort 1 com dez mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista3)

    start_time = time.time()

    insertionSort2(lista3)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista3)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))


ordenar_lista()

import random
import time
import matplotlib.pyplot as plt

def insertionSort(lista):
    for i in range(1, len(lista)):
        aux = lista[i]
        j = i - 1
        while j >= 0 and aux < lista[j]:
            lista[j + 1] = lista[j]
            j -= 1
        lista[j + 1] = aux

def ordenar_e_medir_tempo(tamanho):
    lista = [random.randint(-99999, 99999) for _ in range(tamanho)]

    start_time = time.time()
    insertionSort(lista)
    end_time = time.time()

    execution_time = end_time - start_time

    print(f"Insertion Sort com {tamanho} elementos no vetor:")
    print("Tempo de execução: {:.6f} segundos".format(execution_time))

    return execution_time

tamanhos = [100, 1000, 10000]
tempos = []

for tamanho in tamanhos:
    tempo_execucao = ordenar_e_medir_tempo(tamanho)
    tempos.append(tempo_execucao)

# Calcular os tempos de execução usando o gráfico
plt.figure(figsize=(8, 6))
plt.plot(tamanhos, tempos, marker='o')
plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo de Execução (s)')
plt.title('Tempo de Execução do Insertion Sort')
plt.grid(True)
plt.show()

"""Bubble sort"""

import random
import time

def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

def ordenar_lista():
    cem = 100
    lista1 = []
    mil = 1000
    lista2 = []
    dezm = 10000
    lista3 = []

    for _ in range(cem):
        lista1.append(random.randint(-99999, 99999))

    print("Bubble Sort com cem elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista1)

    start_time = time.time()

    bubble_sort(lista1)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista1)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(mil):
        lista2.append(random.randint(-99999, 99999))

    print("\n\nBubble Sort com mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista2)

    start_time = time.time()

    bubble_sort(lista2)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista2)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(dezm):
        lista3.append(random.randint(-999999, 999999))

    print("\n\nBubble Sort com dez mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista3)

    start_time = time.time()

    bubble_sort(lista3)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista3)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

ordenar_lista()

import random
import time
import matplotlib.pyplot as plt

def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

def ordenar_e_medir_tempo(tamanho):
    lista = [random.randint(-99999, 99999) for _ in range(tamanho)]

    start_time = time.time()
    bubble_sort(lista)
    end_time = time.time()

    execution_time = end_time - start_time

    print(f"Bubble Sort com {tamanho} elementos no vetor:")
    print("Tempo de execução: {:.6f} segundos".format(execution_time))

    return execution_time

tamanhos = [100, 1000, 10000]
tempos = []

for tamanho in tamanhos:
    tempo_execucao = ordenar_e_medir_tempo(tamanho)
    tempos.append(tempo_execucao)

# Calcular os tempos de execução usando o gráfico
plt.figure(figsize=(8, 6))
plt.plot(tamanhos, tempos, marker='o')
plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo de Execução (s)')
plt.title('Tempo de Execução do Bubble Sort')
plt.grid(True)
plt.show()

"""Selection sort:"""

import random
import time

def selection_sort(arr):
    n = len(arr)

    for i in range(n):
        # Encontra o índice do menor elemento não ordenado restante
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j

        # Troca o menor elemento encontrado com o primeiro elemento não ordenado
        arr[i], arr[min_index] = arr[min_index], arr[i]

def ordenar_lista():
    cem = 100
    lista1 = []
    mil = 1000
    lista2 = []
    dezm = 10000
    lista3 = []

    for _ in range(cem):
        lista1.append(random.randint(-99999, 99999))

    print("Selection Sort com cem elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista1)

    start_time = time.time()

    selection_sort(lista1)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista1)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(mil):
        lista2.append(random.randint(-99999, 99999))

    print("\n\nSelection Sort com mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista2)

    start_time = time.time()

    selection_sort(lista2)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista2)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

    for _ in range(dezm):
        lista3.append(random.randint(-999999, 999999))

    print("\n\nSelection Sort com dez mil elementos no vetor:")
    print("\nLista não ordenada:")
    print(lista3)

    start_time = time.time()

    selection_sort(lista3)

    end_time = time.time()
    execution_time = end_time - start_time

    print("\nLista ordenada:")
    print(lista3)

    print("\nTempo de execução: {:.6f} segundos".format(execution_time))

ordenar_lista()

import random
import time
import matplotlib.pyplot as plt

def selection_sort(arr):
    n = len(arr)

    for i in range(n):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j

        arr[i], arr[min_index] = arr[min_index], arr[i]

def ordenar_e_medir_tempo(tamanho):
    lista = [random.randint(-99999, 99999) for _ in range(tamanho)]

    start_time = time.time()
    selection_sort(lista)
    end_time = time.time()

    execution_time = end_time - start_time

    print(f"Selection Sort com {tamanho} elementos no vetor:")
    print("Tempo de execução: {:.6f} segundos".format(execution_time))

    return execution_time

tamanhos = [100, 1000, 10000]
tempos = []

for tamanho in tamanhos:
    tempo_execucao = ordenar_e_medir_tempo(tamanho)
    tempos.append(tempo_execucao)

plt.figure(figsize=(8, 6))
plt.plot(tamanhos, tempos, marker='o')
plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo de Execução (s)')
plt.title('Tempo de Execução do Selection Sort')
plt.grid(True)
plt.show()

"""# Depois do primeiro código , eu decidi juntar todas as funções em 1 só código , porque aí ficava mais fácil a execução e pelo que eu entendi , o Sr queria a comparação entre os algoritmos.

# Eu fui colocando como se fosse os passos do código , então a última célula é a que está com tudo.
"""

import random
import time
import matplotlib.pyplot as plt

def insertionSort(lista):
    for i in range(1, len(lista)):
        aux = lista[i]
        j = i - 1
        while j >= 0 and aux < lista[j]:
            lista[j + 1] = lista[j]
            j -= 1
        lista[j + 1] = aux

def bubble_sort(arr):
    n = len(arr)

    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

def selection_sort(arr):
    n = len(arr)

    for i in range(n):
        min_index = i
        for j in range(i+1, n):
            if arr[j] < arr[min_index]:
                min_index = j

        arr[i], arr[min_index] = arr[min_index], arr[i]

def ordenar_e_medir_tempo(algoritmo, tamanho):
    lista = [random.randint(-99999, 99999) for _ in range(tamanho)]

    start_time = time.time()

    if algoritmo == "Insertion":
        insertionSort(lista)
    elif algoritmo == "Bubble":
        bubble_sort(lista)
    elif algoritmo == "Selection":
        selection_sort(lista)

    end_time = time.time()

    execution_time = end_time - start_time

    print(f"{algoritmo} Sort com {tamanho} elementos no vetor:")
    print("Tempo de execução: {:.6f} segundos".format(execution_time))

    return execution_time

tamanhos = [100, 1000, 10000]
algoritmos = ["Insertion", "Bubble", "Selection"]

tempos = {alg: [] for alg in algoritmos}

for tamanho in tamanhos:
    for algoritmo in algoritmos:
        tempo_execucao = ordenar_e_medir_tempo(algoritmo, tamanho)
        tempos[algoritmo].append(tempo_execucao)


plt.figure(figsize=(8, 6))

for algoritmo in algoritmos:
    plt.plot(tamanhos, tempos[algoritmo], marker='o', label=f'{algoritmo} Sort')

plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo de Execução (s)')
plt.title('Comparação de Tempos de Execução de Algoritmos de Ordenação')
plt.grid(True)
plt.legend()
plt.show()



import random
import time
import matplotlib.pyplot as plt

# Função Merge Sort
def merge_sort(lista):
    if len(lista) <= 1:
        return lista

    meio = len(lista) // 2
    lista_esquerda = lista[:meio]
    lista_direita = lista[meio:]

    lista_esquerda = merge_sort(lista_esquerda)
    lista_direita = merge_sort(lista_direita)

    return merge(lista_esquerda, lista_direita)

def merge(lista_esquerda, lista_direita):
    resultado = []
    i = j = 0

    while i < len(lista_esquerda) and j < len(lista_direita):
        if lista_esquerda[i] < lista_direita[j]:
            resultado.append(lista_esquerda[i])
            i += 1
        else:
            resultado.append(lista_direita[j])
            j += 1

    resultado.extend(lista_esquerda[i:])
    resultado.extend(lista_direita[j:])
    return resultado

# Função Quick Sort
def quick_sort(lista):
    if len(lista) <= 1:
        return lista

    pivo = lista[len(lista) // 2]
    menores = [x for x in lista if x < pivo]
    iguais = [x for x in lista if x == pivo]
    maiores = [x for x in lista if x > pivo]

    return quick_sort(menores) + iguais + quick_sort(maiores)

def ordenar_e_medir_tempo(algoritmo, tamanho):
    lista = [random.randint(-99999, 99999) for _ in range(tamanho)]

    start_time = time.time()

    if algoritmo == "Insertion":
        insertionSort(lista)
    elif algoritmo == "Bubble":
        bubble_sort(lista)
    elif algoritmo == "Selection":
        selection_sort(lista)
    elif algoritmo == "Merge":
        merge_sort(lista)
    elif algoritmo == "Quick":
        quick_sort(lista)

    end_time = time.time()

    execution_time = end_time - start_time

    print(f"{algoritmo} Sort com {tamanho} elementos no vetor:")
    print("Tempo de execução: {:.6f} segundos".format(execution_time)+"\n")

    return execution_time

tamanhos = [100, 1000, 10000]
algoritmos = ["Insertion", "Bubble", "Selection", "Merge", "Quick"]

tempos = {alg: [] for alg in algoritmos}

for tamanho in tamanhos:
    for algoritmo in algoritmos:
        tempo_execucao = ordenar_e_medir_tempo(algoritmo, tamanho)
        tempos[algoritmo].append(tempo_execucao)

# Plotar os tempos de execução usando o gráfico
plt.figure(figsize=(12, 8))

for algoritmo in algoritmos:
    plt.plot(tamanhos, tempos[algoritmo], marker='o', label=f'{algoritmo} Sort')

plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo de Execução (s)')
plt.title('Comparação de Tempos de Execução de Algoritmos de Ordenação')
plt.grid(True)
plt.legend()
plt.show()

import random
import time
import matplotlib.pyplot as plt

def merge_sort(lista):            #Funç~~ao do merge sort
    if (len(lista) <= 1):         #Verifica se a lista é pequena o suficiente
        return lista;

    meio = (len(lista)) // 2
    lista_esquerda = lista[:meio];
    lista_direita = lista[meio:];

    lista_esquerda = merge_sort(lista_esquerda);      #Vem de outra função ambas as listas
    lista_direita = merge_sort(lista_direita);

    return merge(lista_esquerda, lista_direita);      #Retornando o valor que será usado futuramente

def merge(lista_esquerda, lista_direita):             #A função auxiliar do merge sort , que usa as listas filhas da direita e esquerda (foi a melhor forma pelo que eu entendi nessa situação de usar função)
    i = 0;
    j= 0;
    resultado = [];

    while i < len(lista_esquerda) and j < len(lista_direita):     #While com objetivo de mesclar as listas
        if lista_esquerda[i] < lista_direita[j]:
            resultado.append(lista_esquerda[i]);
            i = i+ 1;
        else:
            resultado.append(lista_direita[j])
            j = j + 1

        resultado.extend(lista_esquerda[i:])
        resultado.extend(lista_direita[j:])
        return resultado                            #Essa lista final , é pra guardar os resuktados ordenados


def quick_sort(lista):                              #Função do quick sort
    if len(lista) <= 1:
        return lista

    pivo = lista[len(lista) // 2]                   #Eu pensei em usar o pivot com list comprehension , e então dividi a lista em 3 , com base no valor do pivot
    menores = [x for x in lista if x < pivo]
    iguais = [x for x in lista if x == pivo]
    maiores = [x for x in lista if x > pivo]

    return quick_sort(menores) + iguais + quick_sort(maiores)

def insertionSort(lista):                                         #As funções insertion , selection e bubble , eu praticamente mudei poucascoisas , só pra funcionar aqui , mas mantendo a ideia do código principal lá em cima
    for i in range(1, len(lista)):
        aux = lista[i];
        j = i - 1;
        while j >= 0 and aux < lista[j]:
            lista[j + 1] = lista[j];
            j= j - 1
        lista[j + 1] = aux

def bubble_sort(lista):
    n = len(lista)

    for i in range(n):
        for j in range(0, (n-i)-1):
            if lista[j] > lista[j+1]:
                lista[j], lista[j+1] = lista[j+1], lista[j]

def selection_sort(lista):
    n = len(lista)

    for i in range(n):
        min_index = i;
        for j in range(i + 1 , n):
            if lista[j] < lista[min_index]:
                min_index = j;

        lista[i], lista[min_index] = lista[min_index], lista[i]

def ordenar_e_medir_tempo(algoritmo, tamanho):
    lista = [random.randint(-99999, 99999) for _ in range(tamanho)]

    start_time = time.time()

    if algoritmo == "Insertion":
        insertionSort(lista)
    elif algoritmo == "Bubble":
        bubble_sort(lista)
    elif algoritmo == "Selection":
        selection_sort(lista)
    elif algoritmo == "Merge":
        merge_sort(lista)
    elif algoritmo == "Quick":
        quick_sort(lista)

    end_time = time.time(); #Eu usei novamente a biblioteca time
    execution_time = end_time - start_time;     #Novamente usando a biblioteca time pra medir tempo e ajustar o tempo de execuçãi , fazendo um calculo com a variação de tempo

    print(f"{algoritmo} Sort com {tamanho} elementos no vetor:")            #Esse f na frente do print é pra usar f-strings do python
    print("Tempo de execução: {:.6f} segundos".format(execution_time))

    return execution_time

tamanhos = [100, 1000, 10000]
algoritmos = ["Insertion", "Bubble", "Selection", "Merge", "Quick"]

tempos = {}
for alg in algoritmos:                      #Criei um dicionário vazio com nome tempos e, em seguida, adicionei uma chave para cada algoritmo na lista algoritmos, associando uma lista vazia a cada chave
    tempos[alg] = []

for tamanho in tamanhos:                                  #O código executa algoritmos de ordenação para diferentes tamanhos de vetores ex: Insertion sort , aí executa tal
    for algoritmo in algoritmos:
        tempo_execucao = ordenar_e_medir_tempo(algoritmo, tamanho);   #Ele mede o tempo de execução de cada algoritmo para cada tamanho de vetor
        tempos[algoritmo].append(tempo_execucao);                     #Guarda o tempo que cada algoritmo lebou em um dicionario e usa os dados para criar gráfico

plt.figure(figsize=(12, 8))

for algoritmo in algoritmos:                                          #Esse loop eu achei em um vídeo que o cara mostrava de como usar o matplotlib , aí testei com o código até rodar
    plt.plot(tamanhos, tempos[algoritmo], marker='o', label=f'{algoritmo} Sort')

plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo de Execução(s)')
plt.title('Comparação de Tempos de Execução de Algoritmos de Ordenação')
plt.grid(True)
plt.legend()
plt.show()

import random
import time
import matplotlib.pyplot as plt

def merge_sort(lista):            #Funç~~ao do merge sort
    if (len(lista) <= 1):         #Verifica se a lista é pequena o suficiente
        return lista;

    meio = (len(lista)) // 2
    lista_esquerda = lista[:meio];
    lista_direita = lista[meio:];

    lista_esquerda = merge_sort(lista_esquerda);      #Vem de outra função ambas as listas
    lista_direita = merge_sort(lista_direita);

    return merge(lista_esquerda, lista_direita);      #Retornando o valor que será usado futuramente

def merge(lista_esquerda, lista_direita):             #A função auxiliar do merge sort , que usa as listas filhas da direita e esquerda (foi a melhor forma pelo que eu entendi nessa situação de usar função)
    i = 0;
    j= 0;
    resultado = [];

    while i < len(lista_esquerda) and j < len(lista_direita):     #While com objetivo de mesclar as listas
        if lista_esquerda[i] < lista_direita[j]:
            resultado.append(lista_esquerda[i]);
            i = i+ 1;
        else:
            resultado.append(lista_direita[j])
            j = j + 1

        resultado.extend(lista_esquerda[i:])
        resultado.extend(lista_direita[j:])
        return resultado                            #Essa lista final , é pra guardar os resuktados ordenados


def quick_sort(lista):                              #Função do quick sort
    if len(lista) <= 1:
        return lista

    pivo = lista[len(lista) // 2]                   #Eu pensei em usar o pivot com list comprehension , e então dividi a lista em 3 , com base no valor do pivot
    menores = [x for x in lista if x < pivo]
    iguais = [x for x in lista if x == pivo]
    maiores = [x for x in lista if x > pivo]

    return quick_sort(menores) + iguais + quick_sort(maiores)

def insertionSort(lista):                                         #As funções insertion , selection e bubble , eu praticamente mudei poucascoisas , só pra funcionar aqui , mas mantendo a ideia do código principal lá em cima
    for i in range(1, len(lista)):
        aux = lista[i];
        j = i - 1;
        while j >= 0 and aux < lista[j]:
            lista[j + 1] = lista[j];
            j= j - 1
        lista[j + 1] = aux

def bubble_sort(lista):
    n = len(lista)

    for i in range(n):
        for j in range(0, (n-i)-1):
            if lista[j] > lista[j+1]:
                lista[j], lista[j+1] = lista[j+1], lista[j]

def selection_sort(lista):
    n = len(lista)

    for i in range(n):
        min_index = i;
        for j in range(i + 1 , n):
            if lista[j] < lista[min_index]:
                min_index = j;

        lista[i], lista[min_index] = lista[min_index], lista[i]
def ordenar_e_medir_tempo(algoritmo, tamanho):
    tempos_execucao = [];

    for _ in range(5):  # Executa o algoritmo 5 vezes com valores diferentes
        lista = [random.randint(-99999, 99999) for _ in range(tamanho)];
        start_time = time.time();

        if algoritmo == "Insertion":
            insertionSort(lista);
        elif algoritmo == "Bubble":
            bubble_sort(lista);
        elif algoritmo == "Selection":
            selection_sort(lista);

        elif algoritmo == "Merge":
            merge_sort(lista);
        elif algoritmo == "Quick":
            quick_sort(lista);

        end_time = time.time();
        execution_time = end_time - start_time;
        tempos_execucao.append(execution_time);


    media_tempo = sum(tempos_execucao) / len(tempos_execucao);          #Calcula a média dos tempos de execução

    print(f"{algoritmo} Sort com {tamanho} elementos no vetor:");
    print("Tempo médio de execução: {:.8f} segundos".format(media_tempo)+"\n");

    return media_tempo;

tamanhos = [100, 1000, 10000];
algoritmos = ["Insertion", "Bubble", "Selection", "Merge", "Quick"];

tempos = {};
for alg in algoritmos:
    tempos[alg] = [];

for tamanho in tamanhos:
    for algoritmo in algoritmos:
        tempo_execucao = ordenar_e_medir_tempo(algoritmo, tamanho);
        tempos[algoritmo].append(tempo_execucao);

plt.figure(figsize=(12, 8))

for algoritmo in algoritmos:
    plt.plot(tamanhos, tempos[algoritmo], marker='o', label=f'{algoritmo} Sort');

plt.xlabel('Tamanho do Vetor')
plt.ylabel('Tempo Médio de Execução(s)')
plt.title('Comparação de Tempos Médios de Execução de Algoritmos de Ordenação')
plt.grid(True)
plt.legend()
plt.show()

